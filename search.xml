<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>消息队列</title>
      <link href="/2021/11/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-rabbit-mq/"/>
      <url>/2021/11/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-rabbit-mq/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列?"></a>什么是消息队列?</h2><p>通俗理解就是生产者用队列的方式发送消息，把要传输的数据放在队列中，消费者从队列中取出消息。</p><h2 id="为什么要引入消息队列-能解决什么问题"><a href="#为什么要引入消息队列-能解决什么问题" class="headerlink" title="为什么要引入消息队列?能解决什么问题?"></a>为什么要引入消息队列?能解决什么问题?</h2><p>消息队列是很重要的分布式中间件，能够应用于流量削峰填谷、应用间解耦、异步处理、消息通讯场景.</p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>很多电商网站都会搞整点秒杀的优惠活动，如果按照传统实现方案，通过传统方式进行秒杀下单，所有的查询创建在秒杀活动开始的时候一瞬间全都打到db server上面去，流量暴增,数据库立马就跪了,服务全跪。<br>显然传统方式是无法应对这种瞬时激增的流量的，那么这时候就要引入流量削峰的方案了，引入消息队列,所有的下单信息发送到消息队列中,并给定一个当前系统能承受的最大请求数量，当超过这个最大数量，多余的流量被丢弃,将被削掉流量的用户引导至错误页面,削峰完成,虽然丢失了一部分流量,但是保证了流量超出系统承受能力的时候，系统不至于崩溃.</p><h3 id="应用间解耦"><a href="#应用间解耦" class="headerlink" title="应用间解耦"></a>应用间解耦</h3><p>案例:系统A提供了一些数据，此时系统B对这些数据比较关注，此时的技术方案是A系统直接将数据通过接口调用发送给系统B,这时问题解决了,A系统成功为B系统提供了数据。</p><hr><p>存在的问题:</p><h4 id="系统A和系统B都存在宕机的可能性，服务的高可用性没有办法保证-通过接口调用的方式存在失败的可能性"><a href="#系统A和系统B都存在宕机的可能性，服务的高可用性没有办法保证-通过接口调用的方式存在失败的可能性" class="headerlink" title="系统A和系统B都存在宕机的可能性，服务的高可用性没有办法保证,通过接口调用的方式存在失败的可能性."></a>系统A和系统B都存在宕机的可能性，服务的高可用性没有办法保证,通过接口调用的方式存在失败的可能性.</h4><h4 id="如果这时又来了系统C-D-E-这时按照刚才的方案，系统A又需要调用系统C，D，E，这时候系统A的开发人员肯定要疯了-同样的逻辑要写3-4次"><a href="#如果这时又来了系统C-D-E-这时按照刚才的方案，系统A又需要调用系统C，D，E，这时候系统A的开发人员肯定要疯了-同样的逻辑要写3-4次" class="headerlink" title="如果这时又来了系统C,D,E,这时按照刚才的方案，系统A又需要调用系统C，D，E，这时候系统A的开发人员肯定要疯了,同样的逻辑要写3,4次."></a>如果这时又来了系统C,D,E,这时按照刚才的方案，系统A又需要调用系统C，D，E，这时候系统A的开发人员肯定要疯了,同样的逻辑要写3,4次.</h4><p>解决方案:<br>这时候如果使用消息队列,系统A的开发人员就解脱了，系统A只需要应用消息队列中的发布订阅模式,将数据简单地丢到消息队列中，对此数据关心的系统直接从消息队列中取出这份数据即可.</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>案例:假设现在有一个简单的登录场景,假设进行登录的时候需要执行3个操作,调用user服务的查询用户接口A,记录访问日志存库操作B,发送推送消息操作C,这三个操作依次耗时20ms,30ms,50ms<br>如果同步处理的话那么在后端服务内的耗时至少是三个操作的总和,返给前端的时候还要计算上TCP连接建立的时间，实际上这个操作中，有一些操作是对于前端交互是毫无关系的,比如操作B和操作C，用户点击登录时<br>用户所关心的是立即登录，并不关心记录日志,发送推送消息这些操作,这些操作完全可以异步处理，非核心的业务逻辑或不要求立刻返回结果的任务完全可以异步执行，而这时就可以使用消息队列来完成这个操作。</p><h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>消息队列还可以应用于线程间通信或者进程间通信,或者应用于纯消息通讯,比如点对点的聊天，或者聊天室这种发布订阅模式。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的锁</title>
      <link href="/2021/07/13/Java-%E9%94%81/"/>
      <url>/2021/07/13/Java-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h1 id="共享锁-VS-排他锁"><a href="#共享锁-VS-排他锁" class="headerlink" title="共享锁 VS 排他锁"></a>共享锁 VS 排他锁</h1><p>共享锁和排它锁是针对锁的共享这方面来说的，即共享锁是可以被多个线程共享的，而排它锁不是</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁又被称为读锁，可以被多个线程所持有，如果线程A对共享资源T加了共享锁，则线程A只能读取共享资源T，并不能对其进行修改，其他线程只能对共享资源T加共享锁，不能加排它锁</p><h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p>排它锁又被称为写锁，如果线程A对共享资源T加了排它锁，则线程A既能对共享资源T读又能进行写操作，其他线程不能对共享资源T加任何类型的锁，其中JDK中的synchronized和Lock中写锁的实现类都是排它锁</p><h1 id="自旋锁-VS-自适应自旋锁"><a href="#自旋锁-VS-自适应自旋锁" class="headerlink" title="自旋锁 VS 自适应自旋锁"></a>自旋锁 VS 自适应自旋锁</h1><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁实际上是按照在线程获取锁失败的时候是否会是否挂起该线程来划分的，自旋锁是指在线程获取共享资源的时候获取锁失败了，认为等一小会儿(进行固定次数的自旋)，就可以获得该资源的锁，而不是通过CPU阻塞线程，切换线程的时间片这种方式，通常情况下这比CPU进行线程切换(涉及到用户态和内核态的转换)的开销要小得多，如果自旋完成后，前面锁定资源的线程已经释放了锁，那么当前线程可以拿到锁，不过这是一个不太确定的情况，有可能自旋完成后，前面的线程还没有释放该资源锁。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程可能只是浪费CPU的时间片，所以自旋的等待时间需要有一定的限度，如果自旋超过了限定次数，没有获得资源锁，就应该挂起线程。</p><p>自旋是通过CAS实现的，类似AtomicInteger中调用unsafe进行自增(do-while循环)就是一个自旋操作，如果修改失败就通过循环修改值，直至修改成功</p><h2 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h2><p>自适应自旋锁是在自旋锁上面进行的改进，它的自旋时间不再是固定值，而是由在同一个自旋锁上一次的自选时间和拥有者的状态来决定的，如果同一个锁对象上，刚刚成功获取过锁，则虚拟机认定它很有可能再次成功，那么它的自旋时间可以允许变得更长，反之则更短</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁又被称为是递归锁，是指同一个线程在外层方法已经拿到锁的情况下，在进入内层方法的时候就会自动拿到锁，java中的Synchronized和ReentrantLock都是可重入锁，可重入锁在一定程度上可以避免死锁的发生。</p><p>比如类A有两个实例方法C,D，这两个方法都被sychronized修饰，在C方法内部调用了D，那么某一个线程在进入C已经拿到锁的情况下进入D方法就会自动拿到锁</p><h1 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h1><p>这些锁实际上是按照锁的状态来区分，并且是专门针对synchronized关键字来说的，但是在对这四种锁描述之前需要对一些概念进行了解:对象头和Monitor</p><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><p>Hotspot虚拟机中，对象在虚拟机中的布局分为3部分，分别是对象头、实例数据、对齐填充<br>普通对象的对象头包括两部分:MarkWord和ClassMetaData Address(类型指针)，如果是数组对象还额外包括一个额外的数组长度部分</p><p><strong>Markword</strong><br>用于存储对象自身的运行数据，如HashCode,GC分代年龄，锁状态标志，线程持有的锁、偏向线程ID,偏向时间戳等等，占用内存大小跟虚拟机位长一致<br><strong>Kclass Pointer</strong><br>类型指针，指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例</p><p><strong>Array Length</strong><br>数组长度</p><p>对象需要存储的数据很多，这已经超出了32bit或者是64bit能表示的限度，此外对象头信息是对象自定义的数据无关的额外存储成本，在考虑虚拟机空间效率的时候，MarkWord被设计成一个非固定的数据结构用来在极小的空间里面存储尽量多的信息，它会根据对象的状态复用自己的存储空间，也就是说MarkWord中存储的内容会伴随着锁的状态变化而变化。</p><p>例如在32bit的hotspot的虚拟机中，其各个锁状态下的存储内容如下所示</p><p><img src="https://s1.ax1x.com/2020/05/11/YYNgrn.jpg" alt="img"><br>图片引用自<a href="https://blog.csdn.net/u010723709/article/details/50341631">Synchronized与三种锁态</a></p><p><strong>Monitor</strong><br>Monitor可以理解为一个同步工具或一种同步机制。每一个Java对象都有一个看不见的锁，称为内部锁或Monitor锁，这个Monitor锁实际上就存在于对象的对象头中，对象头中的若干标志位用于标识锁的锁定状态和被哪个线程拥有，在一个线程需要使用一个对象之前，需要先获得它的内置锁，使用之后还需要释放这个内置锁，在使用过程中其它线程无法获取这个锁。</p><p><strong>Synchronized概述</strong><br>Synchronized在JVM里面的实现是基于进入和退出Monitor对象来获取对象锁从而实现方法同步和代码块同步，不同虚拟机的实现细节可能不一样，但都可以通过成对的MonitorEnter和MonitorExit指令来实现，而MonitorEnter和MonitorExit的执行是通过调用操作系统的互斥原语Mutex Lock来实现的，被阻塞的线程会被挂起等待重新调度，会导致CPU在用户态和内核态两个态之间进行切换，比较耗性能，这也是为什么大家对synchronized的一贯印象就是性能较差的原因，jdk在1.6之后对sychronized进行了一系列调整，后来实际上跟Lock的性能不相上下，其实默认还是推荐用synchronized的，语义清晰、操作简单、无需手动关闭</p><p>同步方法是通过ACC_SYNCHRONIZED标识符来实现同步的<br>同步代码块是通过MonitorEnter和MonitorExit两个指令来实现的</p><p><strong>MonitorEnter</strong><br>插入在同步代码块的起始位置，当代码执行到该指令时，将会尝试获取该对象的monitor的所有权，即尝试获取该对象的锁<br><strong>MonitorExit</strong><br>MonitorExit插入在方法结束和异常处，JVM保证每个MonitorEnter必须有相应的MonitorExit</p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对共享资源进行锁定，所有的线程都能访问并修改资源，但是只有一个线程能修改成功，如果多个线程同时修改同一个值，一定会有一个线程会成功，其他修改失败的线程会不断重试(自旋)直到修改成功，这种无锁的情况实际上适用于竞争度不高(读多写少)的情况下，这样自旋一会儿就能获取到资源的修改权，否则自旋非常浪费CPU资源</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Hotspot虚拟机的作者发现在大多数情况下不仅不存在锁的竞争，甚至锁总是同一个线程多次获得，所以为了降低获取锁的代价而引入了偏向锁。偏向锁就是指一段代码一直被一个线程访问，那么线程会自动获取锁，直接执行同步代码块，从而降低获取锁的代价</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只有一个线程进入临界区</p><h3 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h3><ol><li>获取对象的markword</li><li>检测MarkWord是否为可偏向状态</li><li>如果为可偏向，并且markword中指向的线程是当前线程则执行同步代码</li><li>如果为可偏向，但指向的线程不是当前线程，通过cas竞争，若竞争成功，则执行同步代码，如果不成功执行5</li><li>偏向锁竞争不成功，证明存在多线程竞争情况，此时偏向锁不再适用，到达全局安全点，获得偏向锁的线程将被挂起，偏向锁升级为轻量级锁，被阻塞在安全点的线程继续往下执行同步代码</li></ol><h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><p>线程拥有的偏向锁并不会主动释放，需要等待其他线程来竞争，偏向锁的撤销需要等待全局安全点(没有正在执行的代码的时间点),步骤如下</p><ul><li>判断锁对象是否还处于锁定的状态，如果否，则将其恢复到无锁状态，允许其它线程竞争，如果还处于锁定状态，则挂起拥有偏向锁的线程，并将指向该线程的lock record的指针放入对象头的mark word中，升级为轻量级锁(00),然后恢复刚才拥有偏向锁的线程，进入轻量级锁的竞争模式</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果存在锁的竞争，会带来锁撤销的消耗</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>当锁是偏向锁的时候，被其他线程访问出现锁的竞争的时候，就会升级为偏向锁，或者显式关闭偏向锁(jdk1.6以后默认开启，并且默认加的是偏向锁，显式关闭后，默认加的就是轻量级锁),其他线程会通过自旋的方式尝试获取锁，不会阻塞，从而提高性能，一般来说，轻量级锁认为竞争存在，但是竞争的程度较轻，一般两个线程对同一个锁的操作都会错开，或者一个没有拿到锁的线程稍微自旋一会儿就可以拿到锁，如果超过一定自旋的次数后还是没有拿到锁，或者一个线程持有锁，一个线程在自旋的时候，这时候又有第三个线程来竞争锁的时候，轻量级锁就会升级为重量级锁</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>多个线程交替进入临界区，同步代码执行速度较快</p><h4 id="锁的获取-1"><a href="#锁的获取-1" class="headerlink" title="锁的获取"></a>锁的获取</h4><ol><li><p>判断当前对象是否为无锁状态(是否为偏向锁位0，锁标志位01)，若是,JVM会在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储锁对象目前MarkWord的拷贝</p></li><li><p>将对象头中的MarkWord拷贝到LockRecord中</p></li><li><p>拷贝成功后，JVM利用CAS尝试将对象头中MarkWord中设置为指向LockRecord的指针,如果成功执行4，否则执行5</p></li><li><p>更新成功，这个线程就拥有了这个对象的锁，并且将对象MarkWord的标志位转为00，表示此对象处于轻量级锁状态</p></li><li><p>更新失败，虚拟机会检查对象头中MarkWord是否指向当前线程的栈帧，如果是，代表当前线程已经获取到了这个对象的锁，可以直接执行同步代码，否则自旋执行步骤3，如果自旋结束还没有获得锁，则说明锁的竞争比较激烈，需要膨胀为重量级锁，将MarkWord里面的锁标志位置为10，MarkWord里面这时存放的是重量级锁的指针</p><h4 id="锁的释放-1"><a href="#锁的释放-1" class="headerlink" title="锁的释放"></a>锁的释放</h4></li><li><p>使用CAS用线程中MarkWord的拷贝替换对象头中的MarkWord,替换成功则执行2，否则执行3</p></li><li><p>替换成功，则锁释放成功，整个同步过程完成，对象恢复到无锁的状态</p></li><li><p>替换失败，说明有其他线程正在竞争锁，在释放锁的同时，唤醒被挂起的线程</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li></ol><p>始终得不到锁的线程，自旋会消耗CPU资源，造成浪费</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁依靠对象的Monitor锁实现，而Monitor锁又依赖操作系统的Mutex Lock(互斥锁)来实现的</p><ul><li>在同步代码块中，jvm通过monitorenter和monitorexit实现同步锁的获取和释放。</li><li>monitorenter在编译后插入到同步代码块的起始位置，monitorexit被插入到方法结束和异常处。</li><li>线程执行monitorenter的时候会尝试获取对象对应的monitor的所有权，即尝试获对象锁<br>线程执行monitorexit的时候将会把进入次数-1直到进入次数为0的时候释放锁</li><li>同一时刻只有一个线程能够成功，其他失败的线程会放弃锁的竞争被阻塞，放到同步队列中并且等待锁的释放，状态变为Blocked状态，当这个对象锁被释放的时候，会通知队列中等待这个对象锁的线程，使其可以重新竞争锁</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>多个线程同时进入临界区，同步代码执行时间较长</p><h1 id="Synchronized用法"><a href="#Synchronized用法" class="headerlink" title="Synchronized用法"></a>Synchronized用法</h1><h2 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h2><p>获取的是对象锁，锁住的是类的实例对象</p><h2 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h2><p>被锁住的是类的class对象</p><h2 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h2><p>被锁住的是实例对象</p>]]></content>
      
      
      <categories>
          
          <category> java中的锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务隔离</title>
      <link href="/2021/04/05/sql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2021/04/05/sql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库的隔离级别（事务在读另一个事务的数据）"><a href="#数据库的隔离级别（事务在读另一个事务的数据）" class="headerlink" title="数据库的隔离级别（事务在读另一个事务的数据）"></a><strong>数据库的隔离级别（事务在读另一个事务的数据）</strong></h3><p>数据库事务的隔离级别由低到高依次为: <strong>Read uncommitted 、Read committed 、Repeatable read 、Serializable</strong>。</p><p><strong>1. Read uncommitted 读未提交</strong></p><p>A事务能读取B事务整个过程的数据。如果中途回滚、可能会造成回滚前后数据不一致（脏读）</p><p><strong>2. Read committed 读提交</strong></p><p>解决脏读：事务提交后才能获取到修改的数据</p><p>A事务只能读取B事务开始前与提交后的数据。A事务有两次查询某个数据，第一次是在B事务开始前，第二次在B事务提交后，两次查询结果不同（不可重复读）</p><p><strong>3. Repeatable read 重复读</strong>（mysql默认开启的隔离级别）</p><p>解决不可重复读。</p><p>A事务读取某个数据时，B事务可读但不可以做修改，直到A事务提交之后。</p><p><strong>4. 串行化(Serializable)</strong></p><p>解决了幻读的问题。</p><p>事务只能一个接着一个地执行，不能并发执行，隔离级别最重。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//todo ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
          <category> 事务隔离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次docker部署mysql主从复制(单向)</title>
      <link href="/2020/09/02/sql-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E9%83%A8%E7%BD%B2mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%8D%95%E5%90%91/"/>
      <url>/2020/09/02/sql-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E9%83%A8%E7%BD%B2mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%8D%95%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><h5 id="主数据库操作mysql时，生成二进制日志。从数据库向主数据库请求到更新的二进制日志后，根据日志同步从数据库；"><a href="#主数据库操作mysql时，生成二进制日志。从数据库向主数据库请求到更新的二进制日志后，根据日志同步从数据库；" class="headerlink" title="主数据库操作mysql时，生成二进制日志。从数据库向主数据库请求到更新的二进制日志后，根据日志同步从数据库；"></a>主数据库操作mysql时，生成二进制日志。从数据库向主数据库请求到更新的二进制日志后，根据日志同步从数据库；</h5><h4 id="MySQL主从复制的三个线程："><a href="#MySQL主从复制的三个线程：" class="headerlink" title="MySQL主从复制的三个线程："></a>MySQL主从复制的三个线程：</h4><p><strong>1.主节点： binarylog dump thread(用于记录日志binary log)</strong></p><p><strong>2.从节点：I/O thread(接收主节点binlog dump 进程发来的更新以后，保存到relay-log中)</strong></p><p><strong>3.从节点：SQL thread(负责读取relay log，解析成具体的操作并执行，最终保证主从数据的一致性)</strong></p><p>如下图所示:</p><p><img src="https://pic1.zhimg.com/80/v2-1b0c3f31bd398c39b9e0930059b0ca24_1440w.jpg" alt="img"></p><h3 id="环境：docker、mysql版本8-0"><a href="#环境：docker、mysql版本8-0" class="headerlink" title="环境：docker、mysql版本8.0"></a>环境：docker、mysql版本8.0</h3><p><strong>步骤：</strong></p><ol><li><strong>配置一个服务器为 master。</strong></li><li><strong>配置一个服务器为 slave。</strong></li><li><strong>将 slave 连接到 master。</strong></li></ol><h3 id="配置master"><a href="#配置master" class="headerlink" title="配置master:"></a>配置master:</h3><h5 id="将一台服务器配置为-master，要确保服务器有-binlog-和-唯一的服务器ID。"><a href="#将一台服务器配置为-master，要确保服务器有-binlog-和-唯一的服务器ID。" class="headerlink" title="将一台服务器配置为 master，要确保服务器有 binlog 和 唯一的服务器ID。"></a>将一台服务器配置为 master，要确保服务器有 binlog 和 唯一的服务器ID。</h5><p>在 my.cnf 中加入以下配置：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log-bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p><strong>在 Master 上创建一个特殊复制权限的用户给slave使用:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;username&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE,SUPER,RELOAD ON *.* TO &#x27;username&#x27;;</span><br></pre></td></tr></table></figure><h3 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave:"></a>配置slave:</h3><p><strong>在 my.cnf 中加入以下配置(relay 是中继的意思)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id=2</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br></pre></td></tr></table></figure><h3 id="让slave连接master"><a href="#让slave连接master" class="headerlink" title="让slave连接master:"></a>让slave连接master:</h3><p>在 slave 上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">             MASTER_HOST = &#x27;172.17.0.2&#x27;,</span><br><span class="line">             MASTER_PORT = 3306,</span><br><span class="line">             MASTER_USER = &#x27;username&#x27;,</span><br><span class="line">             MASTER_PASSWORD = &#x27;password&#x27;,</span><br><span class="line">             GET_MASTER_PUBLIC_KEY = 1;</span><br><span class="line">mysql&gt; START SLAVE;</span><br></pre></td></tr></table></figure><p><strong>显示是否配置成功，slave中执行：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SLAVE STATUS;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show slave status \G:</span></span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">​        Slave_IO_State: Waiting for source to send event</span><br><span class="line"></span><br><span class="line">​         Master_Host: 172.17.0.3</span><br><span class="line"></span><br><span class="line">​         Master_User: repl</span><br><span class="line"></span><br><span class="line">​         Master_Port: 3306</span><br><span class="line"></span><br><span class="line">​        Connect_Retry: 60</span><br><span class="line"></span><br><span class="line">​       Master_Log_File: mysql-bin.000009</span><br><span class="line"></span><br><span class="line">​     Read_Master_Log_Pos: 156</span><br><span class="line"></span><br><span class="line">​        Relay_Log_File: cd30dbb10151-relay-bin.000007</span><br><span class="line"></span><br><span class="line">​        Relay_Log_Pos: 371</span><br><span class="line"></span><br><span class="line">​    Relay_Master_Log_File: mysql-bin.000009</span><br><span class="line"></span><br><span class="line">​       Slave_IO_Running: Yes</span><br><span class="line"></span><br><span class="line">​      Slave_SQL_Running: Yes</span><br><span class="line"></span><br><span class="line">​       Replicate_Do_DB: </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于mysql优化</title>
      <link href="/2020/07/08/sql-mysql%E4%BC%98%E5%8C%96/"/>
      <url>/2020/07/08/sql-mysql%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h3><p><strong>索引的选择性</strong>是指: 不重复的索引值数和记录总数的比值。</p><p>让选择性最强的索引列放在前面。例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h3 id="否定查询不能使用索引"><a href="#否定查询不能使用索引" class="headerlink" title="否定查询不能使用索引"></a>否定查询不能使用索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>应该修改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where id in (2,5,6);</span><br></pre></td></tr></table></figure><p>前导模糊查询不能使用索引, 如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%zhangsan&#x27;</span></span><br></pre></td></tr></table></figure><p>非前导则可以:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;zhangsan%&#x27;</span></span><br></pre></td></tr></table></figure><p>建议可以考虑使用 <code>Lucene</code> 等全文索引工具来代替频繁的模糊查询。</p><h3 id="数据区分不明显的不建议创建索引"><a href="#数据区分不明显的不建议创建索引" class="headerlink" title="数据区分不明显的不建议创建索引"></a>数据区分不明显的不建议创建索引</h3><p>如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。</p><h3 id="字段的默认值不要为-null"><a href="#字段的默认值不要为-null" class="headerlink" title="字段的默认值不要为 null"></a>字段的默认值不要为 null</h3><p>这样会带来和预期不一致的查询结果。</p><h3 id="在字段上进行计算不能命中索引"><a href="#在字段上进行计算不能命中索引" class="headerlink" title="在字段上进行计算不能命中索引"></a>在字段上进行计算不能命中索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> FROM_UNIXTIME(create_time) <span class="operator">&lt;</span> CURDATE();</span><br></pre></td></tr></table></figure><p>应该修改为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_time <span class="operator">&lt;</span> FROM_UNIXTIME(CURDATE());</span><br></pre></td></tr></table></figure><h2 id="最左前缀问题"><a href="#最左前缀问题" class="headerlink" title="最左前缀问题"></a>最左前缀问题</h2><p>如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span> <span class="keyword">and</span> pwd <span class="operator">=</span><span class="string">&#x27;axsedf1sd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> pwd <span class="operator">=</span><span class="string">&#x27;axsedf1sd&#x27;</span> <span class="keyword">and</span> username<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span></span><br></pre></td></tr></table></figure><p>但是使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> pwd <span class="operator">=</span><span class="string">&#x27;axsedf1sd&#x27;</span></span><br></pre></td></tr></table></figure><p>是不能命中索引的。</p><h2 id="如果明确知道只有一条记录返回"><a href="#如果明确知道只有一条记录返回" class="headerlink" title="如果明确知道只有一条记录返回"></a>如果明确知道只有一条记录返回</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以提高效率，可以让数据库停止游标移动。</p><h2 id="不要让数据库帮我们做强制类型转换"><a href="#不要让数据库帮我们做强制类型转换" class="headerlink" title="不要让数据库帮我们做强制类型转换"></a>不要让数据库帮我们做强制类型转换</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> telno<span class="operator">=</span><span class="number">18722222222</span></span><br></pre></td></tr></table></figure><p>这样虽然可以查出数据，但是会导致全表扫描。需要修改为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> telno<span class="operator">=</span><span class="string">&#x27;18722222222&#x27;</span></span><br></pre></td></tr></table></figure><p>如果需要进行 join 的字段两表的字段类型要相同, 不然也不会命中索引</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式不只是匿名类的语法糖</title>
      <link href="/2020/06/09/Java-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%8F%AA%E6%98%AF%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2020/06/09/Java-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%8F%AA%E6%98%AF%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<h4 id="表达式简介"><a href="#表达式简介" class="headerlink" title="表达式简介"></a>表达式简介</h4><p>Lambda表达式通常使用<code>(argument) -&gt; (body)</code>语法书写，如👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2...) -&gt; &#123;body&#125;</span><br><span class="line">(type1 arg1, type2 arg2...) -&gt; &#123;body&#125;</span><br></pre></td></tr></table></figure><p>一些Lambda表达式例子👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; &#123;<span class="keyword">return</span> a + b&#125;</span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line">() -&gt; &#123;<span class="keyword">return</span> <span class="number">3.1415</span>&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="表达式结构"><a href="#表达式结构" class="headerlink" title="表达式结构"></a>表达式结构</h4><ul><li>一个Lambda表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a,b)</code>或<code>(int a, int b)</code>或<code>(String a, int b, float c)</code></li><li>空圆括号代表参数集为空。例如<code>() -&gt; 42</code></li><li>当只有一个参数，且其类型可推导时，圆括号可省略，如<code>a -&gt; return a*a</code></li><li>Lambda表达式的主体可能包含零条或多条语句</li><li>如果Lambda表达式的主体只有一条语句，花括号可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包含在花括号中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><hr><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>在Java中，Marker（标记）类型的接口是一种没有方法或属性声明的接口。简单地说，Marker接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</p><p><code>java.lang.Runnable</code>就是一种函数式接口，在Runnable接口中之声明了一个方法<code>void run()</code>，相似地，ActionListener接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了Lambda表达式，这一方式可以得到简化。</p><p>每个Lambda表达式都能隐式地赋值给函数式接口，例如，我们可以通过Lambda表达式创建Runnable接口的引用👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><p>当不指明函数式接口时，编译器会自动解释这种转化👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名<code>public Thread(Runnable r) &#123;&#125;</code>，将该Lambda表达式赋给Runnable接口。</p><p>其他Lambda表达式及其函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt; c = (<span class="keyword">int</span> x) -&gt; &#123;System.out.println(x)&#125;;</span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">&quot; : &quot;</span> + y);</span><br><span class="line">Predicater&lt;String&gt; p = (String s) -&gt; &#123;s == <span class="keyword">null</span>&#125;;</span><br><span class="line">以下是一种自定义的函数式接口👇</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好函数式接口后，我们就可以使用了👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerInterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(WorkerInterface worker)</span> </span>&#123;</span><br><span class="line">        worker.doSomeWork();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// old method in java 7</span></span><br><span class="line">        execute(<span class="keyword">new</span> WorkerInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Work in Java 7&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// new method in java 8</span></span><br><span class="line">        execute( () -&gt; &#123;System.out.println(<span class="string">&quot;Work in Java 8&quot;</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>线程通过Lambda初始化</p></li><li><p>PS：Lambda可以视为一个匿名内部类对象，我们创建的Lambda表达式实质是创建一个对象，所以只要我们创建了接口对应的对象，然后将对应传递给指定的方法，即可完成方法的实际调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old method</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello From Java 7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// new method</span></span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">&quot;Hello From Java 8&quot;</span>); ).start();</span><br></pre></td></tr></table></figure></li><li><p>Swing的事件处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old method</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using old method click the button&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// new method</span></span><br><span class="line">button.addActionListener( (e) -&gt; System.out.println(<span class="string">&quot;Using new method click the button&quot;</span>););</span><br></pre></td></tr></table></figure></li><li><p>打印给定数组中的所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old method</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer n : list) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// new method</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">list.forEach(n -&gt; System.out.println(n));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// another method</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>打印list中每个元素的平方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old method</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// new method</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">list.stream().map((x) -&gt; x*x).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Lambda与匿名内部类"><a href="#Lambda与匿名内部类" class="headerlink" title="Lambda与匿名内部类"></a>Lambda与匿名内部类</h4><ul><li>对于匿名内部类，关键字<code>this</code>解读为匿名类</li><li>对于Lambda表达式，关键词<code>this</code>解读为Lambda的外部类，且Java在编译代码时将Lambda表达式转化为类内的私有函数，它使用Java 7中的<code>invokedynamic</code>指令动态绑定该方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java8 java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/2020/06/09/docker-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/09/docker-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="一、镜像相关1"><a href="#一、镜像相关1" class="headerlink" title="一、镜像相关1"></a>一、镜像相关1</h3><table><thead><tr><th>command</th><th>describe</th></tr></thead><tbody><tr><td>docker images</td><td>查看已存在的镜像</td></tr><tr><td>docker images -a docker images -q docker images -qa docker images –digests</td><td>查看已存在的镜像的内部 查看已存在的镜像的ID 查看全部镜像的id 查看镜像说明</td></tr><tr><td>docker search xxx</td><td>查看某个镜像 (xxx=tomcat就是查看tomcat的镜像说明)</td></tr><tr><td>docker pull xxx:tag</td><td>下载某个镜像 (xxx：镜像名，tag：镜像版本)</td></tr><tr><td>docker rmi name/id:tag docker rmi -f name/id:tag</td><td>删除某个镜像 强制删除某个镜像</td></tr></tbody></table><h3 id="二、DockerFile"><a href="#二、DockerFile" class="headerlink" title="二、DockerFile"></a>二、DockerFile</h3><table><thead><tr><th>name</th><th>describe</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，当前新镜像是基于哪个镜像的（scratch就相当于Java里面的Object）</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>容器构建时需要运行的命令</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登录进来的工作目录，一个</td></tr><tr><td>ENV</td><td>用来在构建镜像过程中涉及环境变量</td></tr><tr><td>ADD</td><td>从宿主机拷贝并解压</td></tr><tr><td>COPY</td><td>从宿主机只拷贝</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于保存和持久化工作</td></tr><tr><td>CMD</td><td>指定一个容器启动时要运行的命令,只有最后一个会生效，并且会被docker run 后面的参数替换掉</td></tr><tr><td>ENTRYPOINT</td><td>指定一个容器启动时要运行的命令，每一个都会被生效</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承的Dockerfile时运行命令，父镜像在被子镜像继承后，父镜像的ONBUILD被触发</td></tr></tbody></table><h3 id="三、容器相关"><a href="#三、容器相关" class="headerlink" title="三、容器相关"></a>三、容器相关</h3><table><thead><tr><th align="left">command</th><th>describe</th></tr></thead><tbody><tr><td align="left">docker ps docker ps -as docker ps -l docker ps -n 3</td><td>查看正在运行的容器 查看全部的容器 上一次运行的容器 上三次运行的容器</td></tr><tr><td align="left">docker start id</td><td>启动容器</td></tr><tr><td align="left">docker stop id</td><td>关闭容器</td></tr><tr><td align="left">docker kill id</td><td>强制停止</td></tr><tr><td align="left">docker rm id</td><td>删除容器</td></tr><tr><td align="left">docker rm -f id</td><td>强制删除容器</td></tr><tr><td align="left">docker exec -it id xxx docker exec -it id /bin/bash</td><td>在容器外面去执行一个命令，xxx 就是你要执行的命令 进入某个容器</td></tr><tr><td align="left">ctrl+p+Q</td><td>退出不关闭容器</td></tr><tr><td align="left"></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于redis缓存的问题</title>
      <link href="/2020/03/18/redis-redis%E7%9A%84%E5%87%A0%E6%80%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/18/redis-redis%E7%9A%84%E5%87%A0%E6%80%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li><strong>问题来源</strong></li></ul><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><p>如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><ul><li><strong>解决方案</strong></li></ul><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li><strong>问题来源</strong></li></ul><p>缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p><ul><li><strong>解决方案</strong></li></ul><p>1、设置热点数据永远不过期。</p><p>2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务  不可用时候，进行熔断，失败快速返回机制。</p><p>3、加互斥锁</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li><strong>问题来源</strong></li></ul><p>缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机</strong>。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><ul><li><strong>解决方案</strong></li></ul><ol><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF跨站请求伪造</title>
      <link href="/2019/09/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-csrf/"/>
      <url>/2019/09/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-csrf/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击?"></a>什么是CSRF攻击?</h3><p><strong>CSRF:</strong> Cross Site Regust Forgery跨站请求伪造</p><p>一个正常的请求会将合法用户的session id保存到浏览器的cookie。这时候，如果用户在浏览器中打来另一个tab页，那这个<br>tab页也是可以获得浏览器的cookie。黑客就可以利用这个cookie信息进行攻击。</p><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><h4 id="原理及过程"><a href="#原理及过程" class="headerlink" title="原理及过程"></a>原理及过程</h4><ol><li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1、某银行网站A可以以GET请求的方式发起转账操作。<code>www.xx.com/transfor.do?accountNum= 100&amp;money= 1000</code>,accountNum表示目标账户。这个请求肯定是需要登录才可以正常访问的。</p><p>2、攻击者在某个论坛或者网站上，上传一 个图片，链接地址是<code>www.xxx.com/transfer.do?accountNum=888&amp;money=10000</code>,其中这个accountNum就是攻击者自己的银行账户。</p><p>3、如果有一个用户，登录了银行网站，然后又打开浏览器的另一个tab页，点击了这个图片。这时，银行就会受理到一个带了正确cookie的请求，就会完成转账。用户的钱就被盗了。</p><h4 id="CSRF漏洞检测"><a href="#CSRF漏洞检测" class="headerlink" title="CSRF漏洞检测"></a>CSRF漏洞检测</h4><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。</p><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><h3 id="CSRF防止方式"><a href="#CSRF防止方式" class="headerlink" title="CSRF防止方式:"></a>CSRF防止方式:</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>1、尽量使用POST请求，限制GET请求。POST请求可以带请求体，攻击者就不容易伪造出请求。</p><p>2、将cookie设置 为HttpOnly : respose.setHeader(“Set-Cookie”,” cookiename=cookievalue;HttpOnly”)。</p><p>3、增加token：<br>在请求中放入一个攻击者无法伪造的信息，并且该信息不存在于cookie当中。<br><code>&lt;input type= &#39;hidden’value= &#39; adfasdf&#39;/&gt;</code>这也是Spring Security框架中采用的防范方式。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于反射</title>
      <link href="/2019/06/09/Java-%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/06/09/Java-%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="常用类的概述"><a href="#常用类的概述" class="headerlink" title="常用类的概述"></a>常用类的概述</h3><p><em><strong>Constructor</strong></em>类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象；</p><p><em><strong>Field</strong></em>表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)；</p><p><em><strong>Method</strong></em>表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven依赖管理</title>
      <link href="/2019/04/10/Java-2018-07-24-maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
      <url>/2019/04/10/Java-2018-07-24-maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h3><p>本文主要总结了，在多module的项目中，父子依赖关系是如何创建及管理的。</p><hr><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>现在假设有这样一个项目：实现一个简单的rpc，则我们需要三个模块：</p><ul><li>注册中心</li><li>服务消费方</li><li>服务提供方</li></ul><p>其中，服务提供方需要注册到注册中心，服务消费方需要从注册中心获取服务提供方的列表，则三个模块都需要注册中心的依赖；服务消费方和服务提供方之间需要进行通信，则这两个模块都需要通信的依赖。</p><h4 id="如何创建一个父子模块的依赖关系"><a href="#如何创建一个父子模块的依赖关系" class="headerlink" title="如何创建一个父子模块的依赖关系"></a>如何创建一个父子模块的依赖关系</h4><p>首先，父子模块的关系体现在</p><ul><li>文件目录结构上的层级</li><li>pom中的管理</li></ul><p>其中，我们在预设的父模块pom.xml中添加如下标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-discover<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-provider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就指定了rpc-discover、rpc-provider、rpc-consumer为rpc-root的子模块，子模块可以使用父模块的依赖。</p><hr><h4 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h4><p>在rpc-root中，通过使用<code>&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;</code>标签来管理依赖的版本。</p><ul><li><p>rpc-root.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.sxl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-root<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-discover<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-provider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>rpc-discover.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.sxl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-root<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-discover<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>这样，我们就可以在rpc-discover模块中使用版本为1.18.8的lombok依赖，再添加更多的依赖，只需要在父模块中对依赖的版本进行统一的管理，子模块只需要继承即可使用。</p><hr><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p>不同于<code>&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;</code>这对标签，在<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>中引入的依赖都会被子项目自动引入，并默认被所有的子项目继承。</p><ul><li><p>rpc-root.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.sxl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-root<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-discover<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-provider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>rpc-consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>rpc-discover.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.sxl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-root<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-discover<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>dependencyManagement</strong>内只进行依赖声明，不实现引入，所以子项目使用<strong>dependencyManagement</strong>的依赖需要显示地声明；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且 version 和 scope 都读取自父 pom; 另外如果子项目中指定了版本号，那么会使用子项目中指定的版本。</p><p><strong>dependencies</strong>的子项目回自动继承声明的全部依赖。</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh 配置</title>
      <link href="/2019/03/09/git-2017-03-18-ssh/"/>
      <url>/2019/03/09/git-2017-03-18-ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh多个秘钥管理"><a href="#ssh多个秘钥管理" class="headerlink" title="ssh多个秘钥管理"></a>ssh多个秘钥管理</h1><h5 id="ssh-agent服务"><a href="#ssh-agent服务" class="headerlink" title="ssh-agent服务"></a>ssh-agent服务</h5><h6 id="管理员模式启动Windows-PowerShell"><a href="#管理员模式启动Windows-PowerShell" class="headerlink" title="管理员模式启动Windows PowerShell"></a>管理员模式启动<strong>Windows PowerShell</strong></h6><h6 id="1-使用下面两个命令行启动ssh-agent服务"><a href="#1-使用下面两个命令行启动ssh-agent服务" class="headerlink" title="1.使用下面两个命令行启动ssh-agent服务"></a>1.使用下面两个命令行启动<em><strong>ssh-agent服务</strong></em></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Service -Name ssh-agent -StartupType Manual</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Start-Service ssh-agent</span><br></pre></td></tr></table></figure><p>2.添加到代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/自定义秘钥名称</span><br></pre></td></tr></table></figure><h3 id="3-配置git"><a href="#3-配置git" class="headerlink" title="3.配置git"></a>3.配置git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email “1044934446@qq.com”</span><br></pre></td></tr></table></figure><p>4.生成密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
